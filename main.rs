use std::convert::From;
use regex::Regex;
use serde_derive::Deserialize;
use std::env;

fn bisect_left(arr: &[u64], x: u64) -> usize {
    match arr.binary_search(&x) {
        Ok(pos) => pos,
        Err(pos) => pos,
    }
}

fn check_real_postcode(postcode: &str) -> bool {
    let postcode_regex = Regex::new(r"^(?:[A-Z]{2}[0-9][A-Z]|[A-Z][0-9][A-Z]|[A-Z][0-9]|[A-Z][0-9]{2}|[A-Z]{2}[0-9]|[A-Z]{2}[0-9]{2})[0-9][A-Z]{2}$").unwrap();
    postcode_regex.is_match(&postcode.replace(" ", "").to_uppercase())
}

fn reverse_difference_compression(list_a: &Vec<u64>) -> Vec<u64> {
    let mut result= Vec::with_capacity(list_a.len());
    let mut last_value = 0;
    for &value in list_a {
        last_value += value;
        result.push(last_value);
    }
    result
}

fn reverse_drop_minus_one(list_a: &Vec<u16>) -> Vec<i32> {
    let mut result = list_a[..2].to_vec();
    for &value in &list_a[2..] {
        if value == 0 {
            result.push(result[result.len() - 2]);
        } else {
            result.push(value);
        }
    }
    result.iter().map(|&x| x - 1).map(|x| x as i32).collect()
}

fn postcode_to_int(postcode: &str) -> u64 {
    u64::from_str_radix(&postcode.replace(" ", "").to_uppercase(), 36).unwrap()
}

#[derive(Clone)]

struct BinaryStoredData<'a, const N: usize, const M: usize>  {
    postcode_keys: [u64; N],
    value_key: [u16; N],
    value_values: [&'a str;M],
}


#[derive(Deserialize, Clone)]
struct StoredData {
    postcode_keys: Vec<u64>,
    value_key: Vec<u16>,
    value_values: Vec<String>,
}

impl<'a, const N: usize, const M: usize> From<BinaryStoredData<'a, N, M>> for StoredData {
    fn from(item: BinaryStoredData<'a, N, M>) -> Self {
        StoredData{
            postcode_keys: item.postcode_keys.to_vec(),
            value_key: item.value_key.to_vec(),
            value_values: item.value_values.iter().map(|s| s.to_string()).collect(),
        }
    }
} 


impl StoredData {
    fn from_json(json_str: &str) -> Result<Self, serde_json::Error> {
        serde_json::from_str(json_str)
    }
}

// Declare the static data structure - include data.rs generated by build.rs
include!{concat!(env!("OUT_DIR"), "/data.rs")}

struct PostcodeRangeLookup {
    postcode_keys: Vec<u64>,
    value_key: Vec<i32>,
    value_values: Vec<String>,
}

impl From<StoredData> for PostcodeRangeLookup {
    fn from(item: StoredData) -> Self {
        PostcodeRangeLookup::new(
            reverse_difference_compression(&item.postcode_keys),
            reverse_drop_minus_one(&item.value_key),
            item.value_values.clone(),
        )
    }
}

impl PostcodeRangeLookup {
    fn new(postcode_keys: Vec<u64>, value_key: Vec<i32>, value_values: Vec<String>) -> Self {
        PostcodeRangeLookup{
            postcode_keys,
            value_key,
            value_values,
        }
    }

    fn get_value(&self, postcode: &str, check_valid_postcode: bool) -> Option<String> {
        if check_valid_postcode && !check_real_postcode(postcode) {
            return None;
        }

        if postcode.to_uppercase().starts_with("BT") {
            return None;
        }

        let int_postcode = postcode_to_int(postcode);
        let mut left = bisect_left(&self.postcode_keys, int_postcode);
        if left == 0 && int_postcode != self.postcode_keys[0] {
            return None;
        }

        if left < self.postcode_keys.len() && self.postcode_keys[left] != int_postcode {
            left -= 1;
        }

        if left == self.postcode_keys.len() {
            left -= 1;
        }

        let value_index = self.value_key[left];
        if value_index == -1 || value_index as usize >= self.value_values.len() {
            return None;
        } else {
            Some(self.value_values[value_index as usize].clone())
        }
    }

    fn from_json_file(path: &str) -> Self {
        assert!(std::path::Path::new(path).exists());
        let data = std::fs::read_to_string(path).unwrap();
        match StoredData::from_json(&data) {
            Ok(data) => {
                data.into()
            }
            Err(err) => {
                eprintln!("Failed to parse JSON data: {}", err);
                std::process::exit(1);
            }
        }
    }
}
fn main() {
    // Get the command line argument for the postcode
    let args: Vec<String> = env::args().collect();
    if args.len() < 2 {
        eprintln!("Please provide a postcode as an argument");
        std::process::exit(1);
    }
    let postcode = &args[1];

    // create a lookup using pcon.json
    //let lookup = PostcodeRangeLookup::from_json_file("pcon.json");

    let data: StoredData = DATA.clone().into();

    let lookup: PostcodeRangeLookup = data.into();

    // get the value for the given postcode
    let value = lookup.get_value(postcode, true);

    // Print the result
    match value {
        Some(value) => println!("Value for postcode {}: {}", postcode, value),
        None => println!("No value found for postcode {}", postcode),
    }
}
